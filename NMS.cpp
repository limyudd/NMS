#include <iostream>#include <algorithm>using namespace std;const float FLOAT_EPS = 0.00000001f;const float threshold = 0.24;typedef struct Box{	float x, y, w, h;}Box;typedef struct Detection{	Box box;	float probs;	int class_id;	int oriIndex;}Detection;Detection *dets;/*float overlap(float x1, float w1, float x2, float w2){	float l1 = x1 - w1 / 2;	float l2 = x2 - w2 / 2;	float left = l1 > l2 ? l1 : l2;	float r1 = x1 + w1 / 2;	float r2 = x2 + w2 / 2;	float right = r1 < r2 ? r1 : r2;	return right - left;}float box_intersection(Box a, Box b){	float w = overlap(a.x, a.w, b.x, b.w);	float h = overlap(a.y, a.h, b.y, b.h);	if (w < 0 || h < 0) return 0;	float area = w * h;	return area;}float box_union(Box a, Box b){	float i = box_intersection(a, b);	float u = a.w*a.h + b.w*b.h - i;	return u;}float box_iou(Box a, Box b){	return box_intersection(a, b) / box_union(a, b);}typedef struct {	int index;	int class_id;	float **probs;} sortable_bbox;int nms_comparator(const void *pa, const void *pb){	sortable_bbox a = *(sortable_bbox *)pa;	sortable_bbox b = *(sortable_bbox *)pb;	float diff = a.probs[a.index][b.class_id] - b.probs[b.index][b.class_id];	if (diff < 0) return 1;	else if (diff > 0) return -1;	return 0;}void do_nms_sort_v2(Box *boxes, float **probs, int total, int classes, float thresh){	int i, j, k;	sortable_bbox *s = (sortable_bbox*)calloc(total, sizeof(sortable_bbox));	for (i = 0; i < total; ++i) {		s[i].index = i;		s[i].class_id = 0;		s[i].probs = probs;	}	for (k = 0; k < classes; ++k) {		for (i = 0; i < total; ++i) {			s[i].class_id = k;		}				qsort(s, total, sizeof(sortable_bbox), nms_comparator);		printf("******\n");		for (int i1 = 0; i1 < total; i1++) {			//float prob = s[i].probs;			//if (prob < .24) continue;			printf("%d :", s[i1].index);			for (int i2 = 0; i2 < classes; i2++) {				printf("%f ", s[i1].probs[s[i1].index][i2]);			}			printf("\n");		}		printf("******\n");		for (i = 0; i < total; ++i) {			if (probs[s[i].index][k] == 0) continue;			Box a = boxes[s[i].index];			for (j = i + 1; j < total; ++j) {				Box b = boxes[s[j].index];				if (box_iou(a, b) > thresh) {					probs[s[j].index][k] = 0;				}			}		}	}	free(s);}int max_index(float *a, int n){	if (n <= 0) return -1;	int i, max_i = 0;	float max = a[0];	for (i = 1; i < n; ++i) {		if (a[i] > max) {			max = a[i];			max_i = i;		}	}	return max_i;}*/float cal_iou(Box box1, Box box2){	float intersection_w = min(box1.x + box1.w / 2, box2.x + box2.w / 2) - max(box1.x - box1.w / 2, box2.x - box2.w / 2);	if (intersection_w <= 0) return 0;	float intersection_h = min(box1.y + box1.h / 2, box2.y + box2.h / 2) - max(box1.y - box1.h / 2, box2.y - box2.h / 2);	if (intersection_h <= 0) return 0;	float overlapArea = intersection_w * intersection_h;	float unionArea = (box1.w * box1.h) + (box2.w * box2.h) - overlapArea;	return overlapArea / unionArea;}int nms_compare(void const *a,  void const *b){	Detection *det1 = (Detection *)a;	Detection *det2 = (Detection *)b;	if (det1->probs > det2->probs && det1->class_id == det2->class_id)		return -1;	else if (det1->probs < det2->probs && det1->class_id == det2->class_id) return 1;	return 0;}int index_compare(void const *a, void const *b){	Detection *det1 = (Detection *)a;	Detection *det2 = (Detection *)b;	if (det1->oriIndex > det2->oriIndex) return 1;	else if (det1->oriIndex < det2->oriIndex) return -1;	else return 0;}bool nms_compare_v2(Detection a, Detection b){	return a.probs > b.probs;}void do_nms_sort_v2(Box *boxes, float **probs, int total, int classes, float nms_thresh){	for (int i = 0; i < classes; i++) {		for (int j = 0; j < total; j++){		}		for (int j = 0; j < total; j++) {			for (int k = j+1; k < total; k++) {			}		}	}}void do_nms_sort(Detection *dets, int total, int classes, float nms_thresh){	if (total <= 0) return;	qsort(dets, total, sizeof(Detection), nms_compare);	printf("\n");	for (int i = 0; i < total; i++) {		float prob = dets[i].probs;		//if (prob < .24) continue;		printf("%d %f %f %f %f %f\n", dets[i].class_id, prob, dets[i].box.x, dets[i].box.y, dets[i].box.w, dets[i].box.h);	}	printf("\n");	for (int i = 0; i < total; i++)	{		if (dets[i].probs < threshold) continue; 		//if (dets[i].probs - 0 < FLOAT_EPS) continue;		for (int j = i + 1; j < total; j++)	{			if (dets[j].probs  < threshold ) continue;			if (dets[i].class_id != dets[j].class_id) continue;			float iou = cal_iou(dets[i].box, dets[j].box);			if (iou >= nms_thresh) { // 				dets[j].probs = 0;			}		}	}	}//int main()//{//	int total = 163840;//	int classes = 20;////	Box *boxes = NULL;//	if (boxes == NULL)boxes = (Box*)calloc(total, sizeof(Box));////	float **probs = NULL;//	if (probs == NULL)probs = (float**)calloc(total, sizeof(float *));////	int i = 0;//	for (i = 0; i < total; ++i) {//		probs[i] = NULL;//		if (probs[i] == NULL)probs[i] = (float*)calloc(classes, sizeof(float));//	}////	Detection *dets = NULL;//	if (dets == NULL) dets = (Detection *)calloc(total, sizeof(Detection));//	i = 0;////	float score;//	float x, y, w, h;//	int classId;//	int index = 0;//	FILE *pf = NULL;//	freopen("C:\\Users\\PQMSI\\Desktop\\NMS\\test\\000201.in", "r" , stdin);////	while (scanf("%d%f%f%f%f%f", &classId, &score, &x, &y, &w, &h) != EOF) {//		boxes[index].x = x;//		boxes[index].y = y;//		boxes[index].w = w;//		boxes[index].h = h;//		dets[index].box = boxes[index];//		dets[index].probs = score;//		probs[index][classId] = score;//		dets[index].class_id = classId;//		dets[index].oriIndex = index;//		index++;//	}//	total = index;//	float nms_thresh = 0.4;//////	do_nms_sort(dets, total, classes, nms_thresh);//	//do_nms_sort_v2(boxes, probs, total, classes, nms_thresh);////	//for (i = 0; i < total; ++i) {//	//	int classId = max_index(probs[i], classes);//	//	float prob = probs[i][classId];//	//	if (prob < .24)continue;//	//	printf("%d %f %f %f %f %f\n", classId, prob, boxes[i].x, boxes[i].y, boxes[i].w, boxes[i].h);//	//}////	//	for (int i = 0; i < total; i++)	{//		float prob = dets[i].probs;//		if (prob < .24) continue;//		printf("%d %f %f %f %f %f\n", dets[i].class_id, prob, dets[i].box.x, dets[i].box.y, dets[i].box.w, dets[i].box.h);//	}//	//	if (boxes) {//		free(boxes);//		boxes = NULL;//	}//	if (probs) {//		for (i = 0; i < total; ++i) {//			free(probs[i]);//			probs[i] = NULL;//		}//		free(probs);//		probs = NULL;//	}////	if (dets)//	{//		free(dets);//		dets = NULL;//	}//	return 0;//}